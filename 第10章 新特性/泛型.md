## 泛型

泛型是提供给javac编译器使用的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入，编译器编译带类型说明的集合时会去除掉“类型”信息，使程序运行效率不受影响，对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样。由于编译生成的字节码会去掉泛型的类型信息，只要能跳过编译器，就可以往某个泛型集合中加入其它类型的数据，例如，用反射得到集合，再调用其add方法即可。

泛型引用和创建两端，给出的泛型变量必须相同

## 泛型类

```
A<T>
Class<T> type
```

泛型类中使用泛型

- 成员类型
- 返回值和参数类型
- 局部变量的引用上

```java
class A<T> {
    private T bean;//泛型可在成员变量上使用
    public T fun(T t) {}//泛型可以在类中的方法上（返回值和参数类型）使用！
    public void fun2() {//泛型还可以在局部变量的引用类型上使用
        T b = ...
        new T();//不行的！
    }
}
```

## 泛型方法

```java
public <T> T add(T x, T y){ 
}
```

泛型方法与泛型类没有什么关系，泛型方法不一定非要在泛型类中！

## 泛型的继承和实现

```java
class A<T> {
}

// AA不是泛型类，只是它爸爸是泛型类！
class AA extends A<String> {
  
} 
```

继承泛型类

- 子类不是泛型类：需要给父类传递类型常量

当给父类传递的类型常量为String时，那么在父类中所有T都会被String替换！

```java
class AA1 extends A<String> {
  
}
```

- 子类是泛型类：可以给父类传递类型常量，也可以传递类型变量

```java
class AA3<E> extends A<E> {
  
}
```

## 通配符

-  无限通配符<?>
-  向下通配符<? extends T>
-  向上通配符<? super T>

## 类型推断

- 通过反射的方式获取泛型的实际类型
- 泛型只能是引用类型，不能是基本数据类型

## 泛型擦除

泛型会在编译时擦除，List<String>和List<User>这两个的字节码文件那一个都是List.class

## Gson泛型封装

在[你真的会用Gson吗?Gson使用指南（一）](http://www.jianshu.com/p/e740196225a4) 的第三节我介绍了在Gson中如何使用泛型来简化我们的类设计，但随之而来引入了一个新的问题：封装。不知道各位有没有想过这样一个问题：每次都要用 `new TypeToken<XXX>(){};` 好麻烦，有没有更好的办法?

有更好的办法么?当然有！相信也有不少人自己作了尝试，只是有人欢喜有人愁了，不过没关系，今天我们就来解决这个问题。

### 约定

1、本文涉及到的json格式

```json
// data 为 object 的情况
{"code":"0","message":"success","data":{}}
// data 为 array 的情况
{"code":"0","message":"success","data":[]}
```

2、假定第一种的对应的Java类型为 `Result<XXX>` ，第二种为 `Result<List<XXX>>`

### 为何封装，如何封装

##### 1. 为何封装：

- 写`new TypeToken<XXX>(){}` 麻烦，IDE格式化后还不好看
- 不同的地方每进行一次 `new TypeToken<XXX>(){}` 操作都会生成一个新的类
- 对于任意类`XXX`都只有两种情况`new TypeToken<Result<XXX>>(){}`和`new TypeToken<Result<List<XXX>>>(){}`
- 方便统一管理

##### 2. 如何封装

从上面的我们可以知道，最简单的方法就是提供两个方法分别对应`data`为Array和Object的情况并接收一个参数，即告知XXX的类型，自动将完成`new TypeToken<XXX>(){}`与`new TypeToken<Result<List<XXX>>>(){}`的过程。

**方法原型：**

```java
// 处理 data 为 object 的情况
public static <T> Result<T> fromJsonObject(Reader reader, Class<T> clazz) {}
// 处理 data 为 array 的情况
public static <T> Result<List<T>> fromJsonArray(Reader reader, Class<T> clazz){}
```

### 为何失败?

对于那些尝试着封装过的人可能都这么写过：

```java
public static <T> Result<List<T>> fromJsonArray(Reader reader) {
    Type type = new TypeToken<Result<List<T>>>(){}.getType();
    return GSON.fromJson(reader, type);
}
```

当然上面的写法肯定是没有办法完成的，虽然代码不会报错，但运行结果肯定是不对的，因为这里的`T` 其实是一个 `TypeVariable`，他在运行时并不会变成我们想要的XXX，所以通过`TypeToken` 得到的 泛型信息只是 `"Result<List<T>>"`。

### 如何解决?

既然TypeToken的作用是用于获取泛型的类，返回的类型为`Type`，真正的泛型信息就是放在这个`Type`里面，既然用TypeToken生成会有问题,那我们自己生成Type就行了嘛。

Type是Java中所有类型的父接口，在1.8以前是一个空接口，自1.8起多了个`getTypeName()`方法，下面有`ParameterizedType`、 `GenericArrayType`、 `WildcardType`、 `TypeVariable` 几个接口，以及`Class`类。这几个接口在本次封装过程中只会用到 `ParameterizedType` ，所以简单说一下：

`ParameterizedType` 简单说来就是形如“ **类型<>** ”的类型，如:`Map<String,User>`。下面就以 `Map<String,User>` 为例讲一下里面各个方法的作用。

```java
public interface ParameterizedType extends Type {
     // 返回Map<String,User>里的String和User，所以这里返回[String.class,User.clas]
    Type[] getActualTypeArguments(); 
    // Map<String,User>里的Map,所以返回值是Map.class
    Type getRawType();
    // 用于这个泛型上中包含了内部类的情况,一般返回null
    Type getOwnerType(); 
}
```

所以，知道了这里需要的泛型是怎么回事，一切都好说了，下面我们来完成之前留下的空方法。

#### 1. 实现一个简易的 ParameterizedType

```java
public class ParameterizedTypeImpl implements ParameterizedType {
    private final Class raw;
    private final Type[] args;
    public ParameterizedTypeImpl(Class raw, Type[] args) {
        this.raw = raw;
        this.args = args != null ? args : new Type[0];
    }
    @Override
    public Type[] getActualTypeArguments() {
        return args;
    }
    @Override
    public Type getRawType() {
        return raw;
    }
    @Override
    public Type getOwnerType() {return null;}
}
```

#### 2. 生成Gson需要的泛型

##### 2.1 解析data是object的情况

```java
public static <T> Result<T> fromJsonObject(Reader reader, Class<T> clazz) {
    Type type = new ParameterizedTypeImpl(Result.class, new Class[]{clazz});
    return GSON.fromJson(reader, type);
}
```

##### 2.2 解析data是array的情况

是Array的情况要比是Object的情况多那么一步。

```java
public static <T> Result<List<T>> fromJsonArray(Reader reader, Class<T> clazz) {
    // 生成List<T> 中的 List<T>
    Type listType = new ParameterizedTypeImpl(List.class, new Class[]{clazz});
    // 根据List<T>生成完整的Result<List<T>>
    Type type = new ParameterizedTypeImpl(Result.class, new Type[]{listType});
    return GSON.fromJson(reader, type);
}
```

**本次代码较少，不提供源码**

**虽然这篇博客是以Gson为例，但从上面的内容可以看出实际上和Gson关系不大，主要的内容还是Java的泛型基础，所以这种封装的方法同样适用于其它的框架。**

最后借这次机会给安利一个简易的泛型生成库 **TypeBuilder** ，其最初实现的目的就是让大家快速的生成泛型信息，同时也会作一些参数检查，保证正确性。

用上面的代码给大家举个例子

```java
public static <T> Result<List<T>> fromJsonArray(Reader reader, Class<T> clazz) {
    Type type = TypeBuilder
            .newInstance(Result.class)
            .beginSubType(List.class)
            .addTypeParam(clazz)
            .endSubType()
            .build();
    return GSON.fromJson(reader, type);
}

public static <T> Result<T> fromJsonObject(Reader reader, Class<T> clazz) {
    Type type = TypeBuilder
            .newInstance(Result.class)
            .addTypeParam(clazz)
            .build();
    return GSON.fromJson(reader, type);
}
```
## Type

Type 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型

###  ParameterizedType

ParameterizedType 表示参数化类型，如 Collection<String>

| 方法                                | 说明     |
| :-------------------------------- | :----- |
| Type[ ]  getActualTypeArguments() | 获取真实参数 |

```java
public abstract class BaseProtocol<T> {
    ...
    /**泛型解析*/
    protected T parsejson(String jsonString){
        ParameterizedType genericSuperclass = (ParameterizedType) getClass().getGenericSuperclass();
        Type[] args = genericSuperclass.getActualTypeArguments();
        Type type = args[0];
        return GsonUtil.changeGsonToBean(jsonString,type);
    }
}
```